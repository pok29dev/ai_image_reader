<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Image Metadata Reader</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 12px;
            box-sizing: border-box;
        }
        .toolbar {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 12px;
            flex-shrink: 0;
        }
        h1 {
            color: #81c784;
            margin: 0;
            font-size: 1.25rem;
        }
        .btn-open {
            background-color: #81c784;
            color: #1e1e1e;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
        }
        .btn-open:hover { background-color: #66bb6a; }
        .local-note {
            color: #78909c;
            font-size: 12px;
            margin-left: 8px;
        }
        input[type="file"] { display: none; }

        /* Layout: file list | image view | data view */
        .main-layout {
            display: flex;
            flex: 1;
            gap: 12px;
            min-height: 0;
        }
        .panel-filelist {
            width: 380px;
            min-width: 280px;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .panel-filelist .header {
            padding: 10px 12px;
            background: #383838;
            border-bottom: 1px solid #444;
            font-weight: bold;
            color: #81c784;
        }
        .sort-bar {
            padding: 8px 12px;
            background: #333;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .sort-bar label {
            color: #90a4ae;
            font-size: 12px;
            white-space: nowrap;
        }
        .sort-bar select {
            background: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }
        .sort-bar .btn-collapse {
            margin-left: auto;
            background: #37474f;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 4px 10px;
            font-size: 12px;
            cursor: pointer;
        }
        .sort-bar .btn-collapse:hover { background: #455a64; }
        .file-list {
            flex: 1;
            overflow: auto;
            padding: 8px;
            min-width: 0;
        }
        .file-item {
            padding: 8px 10px;
            cursor: pointer;
            border-radius: 6px;
            margin-bottom: 2px;
            font-size: 13px;
            white-space: nowrap;
        }
        .file-item:hover { background: #383838; }
        .file-item.active {
            background: #37474f;
            color: #81c784;
        }
        .file-item.folder {
            color: #90a4ae;
            font-weight: 500;
        }
        /* Tree view */
        .tree-node { margin-bottom: 2px; }
        .tree-folder {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 13px;
            color: #90a4ae;
            font-weight: 500;
            user-select: none;
        }
        .tree-folder:hover { background: #383838; }
        .tree-toggle {
            width: 16px;
            text-align: center;
            font-size: 10px;
            color: #81c784;
            transition: transform 0.15s ease;
        }
        .tree-node.collapsed .tree-toggle { transform: rotate(-90deg); }
        .tree-children {
            padding-left: 16px;
            border-left: 1px solid #333;
            margin-left: 8px;
        }
        .tree-node.collapsed .tree-children { display: none; }
        
        .panel-image {
            flex: 1;
            min-width: 260px;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .panel-image .header {
            padding: 10px 12px;
            background: #383838;
            border-bottom: 1px solid #444;
            font-weight: bold;
            color: #81c784;
        }
        .image-wrap {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            min-height: 0;
        }
        img#preview {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
            border: 1px solid #444;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .panel-data {
            flex: 1;
            min-width: 320px;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .panel-data .header {
            padding: 10px 12px;
            background: #383838;
            border-bottom: 1px solid #444;
            font-weight: bold;
            color: #81c784;
        }
        .data-inner {
            flex: 1;
            overflow: auto;
            padding: 12px;
        }

        /* Tabs Style */
        .tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .tab-btn {
            background: none;
            border: none;
            color: #888;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
        }
        .tab-btn.active {
            color: #81c784;
            border-bottom: 2px solid #81c784;
        }
        
        .params-block {
            background-color: #263238;
            border: 1px solid #37474f;
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 15px;
        }
        .params-block .params-title {
            color: #81c784;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .params-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 6px 16px;
            font-size: 13px;
        }
        .params-grid .param-label { color: #90a4ae; }
        .params-grid .param-value { color: #e0e0e0; word-break: break-all; }

        .prompt-box {
            background-color: #263238;
            border: 1px solid #37474f;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .prompt-label {
            color: #90a4ae;
            font-size: 0.85em;
            margin-bottom: 5px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }
        .prompt-text {
            white-space: pre-wrap;
            color: #fff;
            font-family: 'Consolas', monospace;
            background: #121212;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .json-viewer {
            background-color: #121212;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            max-height: 500px;
            white-space: pre-wrap;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            color: #a5d6a7;
            border: 1px solid #333;
        }

        .meta-all-list { margin-top: 10px; }
        
        .hidden { display: none; }
        .btn {
            background-color: #81c784;
            color: #1e1e1e;
            padding: 5px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
        }
        .btn:hover { background-color: #66bb6a; }

        /* Dialog block */
        .dialog-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 9998;
            align-items: center;
            justify-content: center;
        }
        .dialog-overlay.is-open {
            display: flex;
        }
        .dialog-block {
            background: #2d2d2d;
            border: 1px solid #555;
            border-radius: 12px;
            padding: 24px;
            min-width: 320px;
            max-width: 90vw;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 9999;
        }
        .dialog-block h2 {
            margin: 0 0 12px 0;
            color: #81c784;
            font-size: 1.1rem;
        }
        .dialog-block p {
            color: #b0bec5;
            font-size: 13px;
            margin: 0 0 20px 0;
            line-height: 1.5;
        }
        .dialog-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .dialog-actions .btn-cancel {
            background: #455a64;
            color: #e0e0e0;
        }
        .dialog-actions .btn-cancel:hover {
            background: #546e7a;
        }
    </style>
</head>
<body>

<div id="folderDialogOverlay" class="dialog-overlay" onclick="closeFolderDialog(event)">
    <div class="dialog-block" onclick="event.stopPropagation()">
        <h2>üìÇ Select Image Folder</h2>
        <p id="folderDialogDesc">Click the button below to open the system folder picker. Select the folder containing your .png files.</p>
        <div class="dialog-actions">
            <button type="button" class="btn btn-cancel" onclick="closeFolderDialog()">Cancel</button>
            <button type="button" class="btn-open" onclick="openFolderPickerFromDialog()">Choose Folder</button>
        </div>
    </div>
</div>

<div class="container">
    <div class="toolbar">
        <h1>üîç AI Image Metadata Reader</h1>
        <button type="button" class="btn-open" onclick="openFolderDialog()">üìÇ Select Folder</button>
        <span class="local-note" id="localNote">Runs locally only ‚Äî No files are uploaded. If your browser asks to "Upload files", it is just granting permission to read them locally.</span>
        <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="pok29dev" data-color="#FFDD00" data-emoji="" data-font="Cookie" data-text="Buy me a coffee" data-outline-color="#000000" data-font-color="#000000" data-coffee-color="#ffffff" ></script>
        <input type="file" id="folderInput" webkitdirectory directory multiple accept="image/png" style="display: none;">
    </div>

    <div class="main-layout">
        <div class="panel-filelist">
            <div class="header">Image Browser ‚Äî Folders / Files</div>
            <div class="sort-bar">
                <label>Sort by:</label>
                <select id="sortBy" onchange="applySort()">
                    <option value="name">Name</option>
                    <option value="date">Date</option>
                    <option value="type">Type</option>
                </select>
                <button type="button" class="btn-collapse" onclick="collapseAll()">Collapse all</button>
            </div>
            <div id="fileList" class="file-list">
                <p style="color: #666; padding: 12px; margin: 0;">Open a folder to list .png files from your device.</p>
            </div>
        </div>

        <div class="panel-image">
            <div class="header">Image View</div>
            <div class="image-wrap">
                <img id="preview" src="" alt="Preview" style="display: none;">
                <p id="imagePlaceholder" style="color: #666; margin: 0;">Select an image from the list</p>
            </div>
        </div>

        <div class="panel-data">
            <div class="header">Data View</div>
            <div class="data-inner">
                <div class="tabs">
                    <button class="tab-btn active" onclick="switchTab('simple')">‚ú® Prompt Text</button>
                    <button class="tab-btn" onclick="switchTab('raw')">üìù Raw JSON</button>
                    <button class="tab-btn" onclick="switchTab('allmeta')">üìã All Metadata</button>
                </div>
                <div id="content-simple">
                    <div id="paramsBlock" class="params-block" style="display: none;">
                        <div class="params-title">Parameters</div>
                        <div class="params-grid" id="paramsGrid"></div>
                    </div>
                    <div id="extractedPrompts">
                        <p style="color: #777; text-align: center;">No prompt found ‚Äî Select an image to view metadata</p>
                    </div>
                </div>
                <div id="content-raw" class="hidden">
                    <h3>Prompt (API) JSON</h3>
                    <div class="json-viewer" id="jsonPrompt">No Data</div>
                    <br>
                    <h3>Workflow JSON</h3>
                    <div class="json-viewer" id="jsonWorkflow">No Data</div>
                </div>
                <div id="content-allmeta" class="hidden">
                    <p style="color: #90a4ae; font-size: 12px; margin-bottom: 10px;">All metadata stored in PNG (including non-ComfyUI chunks)</p>
                    <div id="allPngMeta" class="meta-all-list"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    const folderInput = document.getElementById('folderInput');
    const previewImg = document.getElementById('preview');
    const imagePlaceholder = document.getElementById('imagePlaceholder');
    const fileListEl = document.getElementById('fileList');

    const isElectron = typeof window.electronAPI === 'object';
    let fileMap = {};
    let currentFileItems = [];

    if (isElectron) {
        document.getElementById('folderDialogDesc').textContent = 'Click below to select a folder containing .png files (Desktop App Mode).';
        document.getElementById('localNote').textContent = 'Desktop App ‚Äî Accessing local files only.';
    } else {
        folderInput.addEventListener('change', handleFolder);
    }

    function base64ToArrayBuffer(base64) {
        const bin = atob(base64);
        const buf = new ArrayBuffer(bin.length);
        const view = new Uint8Array(buf);
        for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);
        return buf;
    }

    function openFolderDialog() {
        document.getElementById('folderDialogOverlay').classList.add('is-open');
    }
    function closeFolderDialog(event) {
        if (event && event.target !== event.currentTarget) return;
        const el = document.getElementById('folderDialogOverlay');
        if (el) el.classList.remove('is-open');
    }
    function openFolderPickerFromDialog() {
        if (isElectron) {
            window.electronAPI.selectFolder().then(files => {
                closeFolderDialog();
                if (files && files.length) handleFolderFromElectron(files);
            });
        } else {
            folderInput.click();
            closeFolderDialog();
        }
    }

    function handleFolderFromElectron(files) {
        fileMap = {};
        currentFileItems = files.map(f => {
            fileMap[f.path] = f.fullPath;
            return { path: f.path, name: f.name, folderPath: f.folderPath, lastModified: f.lastModified || 0, ext: f.ext || '' };
        });
        const sortBy = document.getElementById('sortBy');
        renderFileList(currentFileItems, sortBy ? sortBy.value : 'name');
    }

    function handleFolder(e) {
        const files = e.target.files;
        if (!files || files.length === 0) return;

        closeFolderDialog();
        fileMap = {};
        currentFileItems = [];

        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            if (!file.name.toLowerCase().endsWith('.png')) continue;
            if (file.name.startsWith('._')) continue; 
            const path = file.webkitRelativePath || file.name;
            fileMap[path] = file;
            const parts = path.split('/');
            const name = parts.pop();
            const folderPath = parts.join('/');
            const ext = (name.includes('.') ? name.split('.').pop() : '').toLowerCase();
            currentFileItems.push({ path, name, file, folderPath, lastModified: file.lastModified || 0, ext });
        }

        const sortBy = document.getElementById('sortBy');
        renderFileList(currentFileItems, sortBy ? sortBy.value : 'name');
    }

    function applySort() {
        const sortBy = document.getElementById('sortBy');
        if (!sortBy || !currentFileItems.length) return;
        renderFileList(currentFileItems, sortBy.value);
    }

    function collapseAll() {
        fileListEl.querySelectorAll('.tree-node').forEach(node => node.classList.add('collapsed'));
    }

    function renderFileList(items, sortMode) {
        if (!items.length) {
            fileListEl.innerHTML = '<p style="color:#666; padding:12px; margin:0;">No .png files found in this folder</p>';
            return;
        }

        const sorted = [...items].sort((a, b) => {
            if (sortMode === 'name') return (a.name || '').localeCompare(b.name || '', undefined, { numeric: true });
            if (sortMode === 'date') return (b.lastModified || 0) - (a.lastModified || 0);
            if (sortMode === 'type') {
                const c = (a.ext || '').localeCompare(b.ext || '');
                return c !== 0 ? c : (a.name || '').localeCompare(b.name || '', undefined, { numeric: true });
            }
            return 0;
        });

        const byFolder = {};
        sorted.forEach(it => {
            const key = it.folderPath || '(Root)';
            if (!byFolder[key]) byFolder[key] = [];
            byFolder[key].push(it);
        });
        const sortedFolders = Object.keys(byFolder).sort((a, b) => a.localeCompare(b));

        let html = '';
        sortedFolders.forEach(folder => {
            const folderKey = escapeAttr(folder);
            const folderLabel = folder === '(Root)' ? '(Root)' : escapeHtml(folder);
            html += `<div class="tree-node" data-folder="${folderKey}">`;
            html += `<div class="tree-folder file-item folder" data-folder-key="${folderKey}">`;
            html += `<span class="tree-toggle">‚ñº</span><span>üìÅ ${folderLabel}</span>`;
            html += `</div>`;
            html += `<div class="tree-children">`;
            byFolder[folder].forEach(it => {
                html += `<div class="file-item" data-path="${escapeAttr(it.path)}" title="${escapeAttr(it.path)}">${escapeHtml(it.name)}</div>`;
            });
            html += `</div></div>`;
        });

        fileListEl.innerHTML = html;

        fileListEl.querySelectorAll('.tree-folder').forEach(el => {
            el.addEventListener('click', function(e) {
                e.stopPropagation();
                const node = this.closest('.tree-node');
                if (node) node.classList.toggle('collapsed');
            });
        });

        fileListEl.querySelectorAll('.tree-children .file-item').forEach(el => {
            el.addEventListener('click', function(e) {
                e.stopPropagation();
                fileListEl.querySelectorAll('.file-item').forEach(x => x.classList.remove('active'));
                this.classList.add('active');
                const path = this.getAttribute('data-path');
                if (path) selectFile(path);
            });
        });
    }

    function escapeAttr(s) {
        return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    function escapeHtml(s) {
        const div = document.createElement('div');
        div.textContent = s;
        return div.innerHTML;
    }

    function selectFile(path) {
        const fileOrPath = fileMap[path];
        if (!fileOrPath) return;

        if (isElectron) {
            const fullPath = fileOrPath;
            previewImg.style.display = 'block';
            imagePlaceholder.style.display = 'none';
            window.electronAPI.readImage(fullPath).then(r => {
                if (r.error) return;
                if (previewImg.src) URL.revokeObjectURL(previewImg.src);
                previewImg.src = 'data:image/png;base64,' + r.base64;
                const buffer = base64ToArrayBuffer(r.base64);
                extractPngMetadata(buffer);
            });
        } else {
            const file = fileOrPath;
            const imgUrl = URL.createObjectURL(file);
            if (previewImg.src) URL.revokeObjectURL(previewImg.src);
            previewImg.src = imgUrl;
            previewImg.style.display = 'block';
            imagePlaceholder.style.display = 'none';
            const reader = new FileReader();
            reader.onload = function(event) {
                extractPngMetadata(event.target.result);
            };
            reader.readAsArrayBuffer(file);
        }
    }

    function clearDataView() {
        const block = document.getElementById('paramsBlock');
        const grid = document.getElementById('paramsGrid');
        if (block) block.style.display = 'none';
        if (grid) grid.innerHTML = '';
        const container = document.getElementById('extractedPrompts');
        if (container) container.innerHTML = '';
        const jp = document.getElementById('jsonPrompt');
        const jw = document.getElementById('jsonWorkflow');
        if (jp) jp.textContent = '';
        if (jw) jw.textContent = '';
        const allMeta = document.getElementById('allPngMeta');
        if (allMeta) allMeta.innerHTML = '';
    }

    function extractPngMetadata(buffer) {
        clearDataView();
        const dataView = new DataView(buffer);
        const textDecoder = new TextDecoder('utf-8');
        let offset = 8;
        let promptData = null;
        let workflowData = null;
        const allPngMeta = [];

        while (offset < dataView.byteLength) {
            const length = dataView.getUint32(offset);
            const type = textDecoder.decode(new Uint8Array(buffer, offset + 4, 4));
            const payload = new Uint8Array(buffer, offset + 8, length);

            if (type === 'tEXt') {
                let nullIndex = -1;
                for (let i = 0; i < length; i++) { if (payload[i] === 0) { nullIndex = i; break; } }
                if (nullIndex !== -1) {
                    const keyword = textDecoder.decode(payload.slice(0, nullIndex));
                    const text = textDecoder.decode(payload.slice(nullIndex + 1));
                    allPngMeta.push({ keyword, value: text, chunkType: 'tEXt' });
                    if (keyword === 'prompt') try { promptData = JSON.parse(text); } catch (_) {}
                    if (keyword === 'workflow') try { workflowData = JSON.parse(text); } catch (_) {}
                }
            } else if (type === 'zTXt') {
                let nullIndex = -1;
                for (let i = 0; i < length; i++) { if (payload[i] === 0) { nullIndex = i; break; } }
                if (nullIndex !== -1) {
                    const keyword = textDecoder.decode(payload.slice(0, nullIndex));
                    allPngMeta.push({ keyword, value: '(Compressed Data)', chunkType: 'zTXt' });
                }
            } else if (type === 'iTXt') {
                let nullIndex = -1;
                for (let i = 0; i < length; i++) { if (payload[i] === 0) { nullIndex = i; break; } }
                if (nullIndex !== -1) {
                    const keyword = textDecoder.decode(payload.slice(0, nullIndex));
                    const compFlag = payload[nullIndex + 1];
                    let pos = nullIndex + 3;
                    for (let i = pos; i < length; i++) { if (payload[i] === 0) { pos = i + 1; break; } }
                    for (let i = pos; i < length; i++) { if (payload[i] === 0) { pos = i + 1; break; } }
                    const raw = payload.slice(pos);
                    const value = compFlag === 0 ? textDecoder.decode(raw) : '(Compressed Data)';
                    allPngMeta.push({ keyword, value, chunkType: 'iTXt' });
                }
            }
            offset += 12 + length;
        }

        if (!promptData && allPngMeta.length) {
            for (const entry of allPngMeta) {
                if (entry.keyword === 'prompt' || entry.keyword === 'workflow') continue;
                try {
                    const parsed = JSON.parse(entry.value);
                    if (parsed && typeof parsed === 'object' && !Array.isArray(parsed) && Object.values(parsed).some(v => v && v.class_type)) {
                        promptData = parsed;
                        break;
                    }
                } catch (_) {}
            }
        }

        document.getElementById('jsonPrompt').textContent = promptData ? JSON.stringify(promptData, null, 2) : '';
        document.getElementById('jsonWorkflow').textContent = workflowData ? JSON.stringify(workflowData, null, 2) : '';

        renderParamsBlock(promptData);
        extractAndShowPrompts(promptData);
        extractNonStandardPrompts(allPngMeta);
        renderAllPngMetadata(allPngMeta);
    }

    function extractNonStandardPrompts(allPngMeta) {
        const container = document.getElementById('extractedPrompts');
        if (!container || !allPngMeta || allPngMeta.length === 0) return;
        const standardKeywords = { prompt: true, workflow: true };

        for (const entry of allPngMeta) {
            const kw = (entry.keyword || '').toLowerCase();
            const value = entry.value;
            if (typeof value !== 'string' || value.length < 10) continue;
            if (standardKeywords[kw]) continue;

            if (kw.indexOf('xmp') !== -1 || kw.indexOf('adobe') !== -1 || kw.indexOf('xml') !== -1) {
                const boxes = parseXMPForPrompts(value);
                boxes.forEach(b => { appendPromptBox(container, b.title, b.text); });
                continue;
            }

            if (value.length > 50 || value.trim().indexOf('{') !== 0) {
                appendPromptBox(container, 'Metadata: ' + entry.keyword, value);
            }
        }
    }

    function parseXMPForPrompts(xmlStr) {
        const boxes = [];
        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xmlStr, 'text/xml');
            const ns = { dc: 'http://purl.org/dc/elements/1.1/', rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#', exif: 'http://ns.adobe.com/exif/1.0/' };
            let descriptionText = '';
            let userCommentText = '';
            const descNodes = doc.getElementsByTagNameNS(ns.dc, 'description');
            if (descNodes.length) {
                const rdfLi = descNodes[0].getElementsByTagNameNS(ns.rdf, 'li');
                if (rdfLi.length) descriptionText = rdfLi[0].textContent || '';
            }
            const userCommentNodes = doc.getElementsByTagNameNS(ns.exif, 'UserComment');
            if (userCommentNodes.length) {
                const rdfLi = userCommentNodes[0].getElementsByTagNameNS(ns.rdf, 'li');
                if (rdfLi.length) userCommentText = rdfLi[0].textContent || '';
            }
            if (userCommentText) {
                try {
                    const j = JSON.parse(userCommentText);
                    if (j.c) boxes.push({ title: 'Draw Things ‚Äî Positive', text: j.c });
                    if (j.uc) boxes.push({ title: 'Draw Things ‚Äî Negative', text: j.uc });
                } catch (_) {}
            }
            if (descriptionText.trim() && boxes.length === 0) boxes.push({ title: 'XMP Description', text: descriptionText.trim() });
        } catch (_) {}
        return boxes;
    }

    function appendPromptBox(container, title, text) {
        const textId = 'ptext-ns-' + Math.random().toString(36).slice(2, 9);
        const box = document.createElement('div');
        box.className = 'prompt-box';
        box.innerHTML = `
            <div class="prompt-label">
                <span>${escapeHtml(title)}</span>
                <button class="btn" onclick="copyText('${textId}')">Copy</button>
            </div>
            <div class="prompt-text" id="${textId}">${escapeHtml(text)}</div>
        `;
        container.appendChild(box);
    }

    function renderAllPngMetadata(entries) {
        const container = document.getElementById('allPngMeta');
        if (!container) return;
        if (!entries || entries.length === 0) {
            container.innerHTML = '<p style="color:#666;">No metadata found in PNG</p>';
            return;
        }
        const obj = {};
        entries.forEach(entry => {
            const key = entry.chunkType ? `${entry.keyword} (${entry.chunkType})` : entry.keyword;
            obj[key] = entry.value;
        });
        container.innerHTML = '<pre class="json-viewer">' + escapeHtml(JSON.stringify(obj, null, 2)) + '</pre>';
    }

    function renderParamsBlock(promptJson) {
        const block = document.getElementById('paramsBlock');
        const grid = document.getElementById('paramsGrid');
        if (!block || !grid) return;
        const params = extractParamsFromPrompt(promptJson);
        if (!params || (!params.modelName && !params.size && !params.sampler)) {
            block.style.display = 'none';
            return;
        }
        const rows = [];
        if (params.modelName) rows.push(['Model', params.modelName]);
        if (params.size) rows.push(['Size', params.size]);
        if (params.sampler) rows.push(['Sampler', params.sampler]);
        if (params.scheduler) rows.push(['Scheduler', params.scheduler]);
        if (params.step != null) rows.push(['Steps', String(params.step)]);
        if (params.cfg != null) rows.push(['CFG', String(params.cfg)]);

        grid.innerHTML = rows.map(([l, v]) => `<span class="param-label">${escapeHtml(l)}</span><span class="param-value">${escapeHtml(v)}</span>`).join('');
        block.style.display = 'block';
    }

    function extractParamsFromPrompt(promptJson) {
        if (!promptJson || typeof promptJson !== 'object') return null;
        let modelName = null, size = null, sampler = null, scheduler = null, step = null, cfg = null;
        for (const node of Object.values(promptJson)) {
            const type = node.class_type;
            const inputs = node.inputs || {};
            if (type?.includes('Sampler')) {
                sampler = inputs.sampler_name || sampler;
                scheduler = inputs.scheduler || scheduler;
                step = inputs.steps || step;
                cfg = inputs.cfg || cfg;
            }
            if (type?.includes('EmptyLatentImage')) size = `${inputs.width} √ó ${inputs.height}`;
            if (type?.includes('Loader')) modelName = inputs.ckpt_name || inputs.unet_name || modelName;
        }
        return { modelName, size, sampler, scheduler, step, cfg };
    }

    function extractAndShowPrompts(promptJson) {
        const container = document.getElementById('extractedPrompts');
        container.innerHTML = "";
        if (!promptJson) return;
        let foundCount = 0;
        for (const [key, node] of Object.entries(promptJson)) {
            let textValue = null;
            const nodeType = node.class_type;
            if (nodeType === "PrimitiveStringMultiline" || nodeType === "String") textValue = node.inputs?.value;
            else if (nodeType?.includes("CLIPTextEncode")) textValue = node.inputs?.text;
            else if (node.inputs?.text && typeof node.inputs.text === 'string' && node.inputs.text.length > 5) textValue = node.inputs.text;

            if (textValue && textValue.trim()) {
                foundCount++;
                const textId = `ptext-${key}`;
                const box = document.createElement('div');
                box.className = 'prompt-box';
                box.innerHTML = `<div class="prompt-label"><span>Node ${key} (${nodeType})</span><button class="btn" onclick="copyText('${textId}')">Copy</button></div><div class="prompt-text" id="${textId}">${textValue}</div>`;
                container.appendChild(box);
            }
        }
        if (foundCount === 0 && container.innerHTML === "") container.innerHTML = '<p style="color: #777; text-align: center;">No valid prompts detected in nodes.</p>';
    }

    function switchTab(tabName) {
        const tabs = ['simple', 'raw', 'allmeta'];
        tabs.forEach(t => {
            const el = document.getElementById('content-' + t);
            if (el) el.classList.add('hidden');
        });
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        
        document.getElementById('content-' + tabName).classList.remove('hidden');
        const activeIdx = tabs.indexOf(tabName);
        document.querySelectorAll('.tab-btn')[activeIdx].classList.add('active');
    }

    function copyText(elementId) {
        const text = document.getElementById(elementId).innerText;
        navigator.clipboard.writeText(text).then(() => { alert('Copied to clipboard!'); });
    }
</script>
</body>
</html>
